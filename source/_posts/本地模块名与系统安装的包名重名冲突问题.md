---
title: Python本地模块名与系统安装的包名重名冲突问题
date: 2017-10-04 16:15:12 
categories: "Python" 
tags: 
     - Python
     - 模块
description: Python本地模块名与系统安装的包名重名冲突问题
---
本地修改 woe包中的eval模块时，发现 系统老是import
`"D:\ProgramData\Anaconda2\lib\site-packages\woe\eval.py"`
路径下的eval文件。
那是因为我已经安装了woe这个包，然后需要调用我修改后的woe源码的本地模块文件，系统自动优先import的是之前安装的woe版本。


解决方法如下：

    #-*-coding:utf-8-*-
    __author__='boredbird'
    # importwoe.configasconfig
    # importwoe.feature_processasfp
    # importwoe.evalaseval
    
    import imp
    config = imp.load_source('config',r'E:\Code\woe\woe\config.py')
    fp = imp.load_source('feature_process',r'E:\Code\woe\woe\feature_process.py')
    eval = imp.load_source('eval',r'E:\Code\woe\woe\eval.py')

For **Python 3.5+** use:

    import importlib.util
    spec = importlib.util.spec_from_file_location("module.name", "/path/to/file.py")
    foo = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(foo)
    foo.MyClass()

For **Python 3.3** and **3.4** use:

    from importlib.machinery import SourceFileLoader
    foo = SourceFileLoader("module.name", "/path/to/file.py").load_module()
    foo.MyClass()
    # (Although this has been deprecated in Python 3.4.)

For **Python 2** use:

    import imp
    foo = imp.load_source('module.name', '/path/to/file.py')
    foo.MyClass()
There are equivalent convenience functions for compiled Python files and DLLs.
See it [here](http://bugs.python.org/issue21436). 

另外一种方式，将要导入的模块路径添加到系统路径，并且放在`"D:\ProgramData\Anaconda2\lib\site-packages\`这个路径前面。
比如，

    import sys; 
    print('Python %s on %s' % (sys.version, sys.platform))
    sys.path.extend(['E:\\Code\\Python_Crawler', 'E:\\Code\\Python_Exercise_Code', 'E:\\Code\\Python_ML_Code', 'E:/Code/Python_Crawler'])
![](https://i.imgur.com/z2sGDF8.png)
然后再讲你刚添加的路径元素调整在sys.path这个list中的位置。